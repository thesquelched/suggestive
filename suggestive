#! /usr/bin/python3.2

import urwid
import logging
import threading
import mstat
from analytics import Analytics, FractionLovedOrder, BannedOrder
from datetime import datetime
from subprocess import call
from itertools import chain, islice
import re

logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())

ENQUEUE = 'enqueue'
PLAY = 'play'
SEARCH_NEXT = 'search_next'
SEARCH_PREV = 'search_prev'
GO_TO_TOP = 'cursor max left'
GO_TO_BOTTOM = 'cursor max right'

#
# Threads
#


class AppThread(threading.Thread):
    pass


class DatabaseUpdateThread(AppThread):

    def __init__(self, conf, callback, *args, **kwArgs):
        super(DatabaseUpdateThread, self).__init__(*args, **kwArgs)
        self.callback = callback
        self.conf = conf

        self.session = mstat.initialize_sqlalchemy(conf)
        self.mpd = mstat.initialize_mpd(conf)
        self.lastfm = mstat.initialize_lastfm(conf)

    def run(self):
        mstat.update_database(self.session, self.mpd, self.lastfm, self.conf)
        logger.info('Finished update')
        (self.callback)()


#
# Main Functions
#


class Application(object):

    def __init__(self, conf):
        self.conf = conf

        self.mpd = mstat.initialize_mpd(conf)
        session = mstat.initialize_sqlalchemy(conf)
        self.anl = Analytics(session)

        self.suggestions = []
        self.last_updated = datetime.now()

        self.search_matches = []
        self.current_search_index = None

        # urwid stuff
        self.list_view = self.suggestion_list()

        main = urwid.Padding(self.list_view, left=2, right=2)
        self.content = urwid.Filler(main, height=('relative', 100),
                                    valign='middle', top=1, bottom=1)
        self.top = urwid.Frame(self.content)

        self.event_loop = self.main_loop()

    def start_db_update(self):
        self.update_status('Updating database')
        update_thread = DatabaseUpdateThread(self.conf, self.update_event)
        update_thread.daemon = False
        update_thread.start()

    def update_event(self):
        self.event_loop.set_alarm_in(0, self.update_suggestions)

    def update_suggestions(self, *_args):
        logger.info('Update suggestions display')
        self.last_updated = datetime.now()
        self.suggestions = self.get_suggestions()

        self.list_view = self.suggestion_list()
        padded = urwid.Padding(self.list_view, left=2, right=2)
        self.content.set_body(padded)

        self.update_status('Idle')
        self.update_header()

    def get_suggestions(self):
        return self.anl.order_albums([
            FractionLovedOrder(),
            BannedOrder(),
        ])
        #return self.anl.loved_order()
        # return []
        #return self.anl.suggest_albums()

    def enqueue_album(self, widget_, album):
        logger.info('Enqueue: {} - {}'.format(album.artist.name, album.name))
        mpd_tracks = list(chain.from_iterable(
            self.mpd.listallinfo(track.filename) for track in album.tracks))

        for i, track in enumerate(mpd_tracks):
            trackno = str(track.get('track', i))
            trackno = re.sub(r'(\d+)/\d+', r'\1', trackno)
            track['track'] = int(trackno)

        sorted_tracks = sorted(mpd_tracks, key=lambda track: track['track'])
        ids = [self.mpd.addid(track['file']) for track in sorted_tracks]
        return ids

    def play_album(self, widget_, album):
        logger.info('Play: {} - {}'.format(album.artist.name, album.name))
        self.mpd.clear()
        ids = self.enqueue_album(widget_, album)
        if ids:
            self.mpd.playid(ids[0])

    def update_header(self):
        timestamp = self.last_updated.strftime('%Y-%m-%d %H:%M:%S')
        upd = urwid.Text('Last updated: {}'.format(timestamp))
        header = urwid.Pile([upd, urwid.Divider('\u2500')])
        self.top.set_header(header)

        return header

    def update_status(self, status):
        status = urwid.Text(status)
        footer = urwid.Pile([urwid.Divider('\u2500'), status])
        self.top.set_footer(footer)

        return footer

    def dispatch(self, key):
        if key == 'q':
            raise urwid.ExitMainLoop()
        elif key == 'u':
            self.start_db_update()
        elif key == 'r':
            self.update_suggestions()
        elif key == '~':
            self.event_loop.screen.stop()
            call('ncmpcpp', shell=True)
            self.event_loop.screen.start()
        elif key in ('/', '?'):
            reverse = (key == '?')
            self.start_search(reverse=reverse)
        else:
            return False

        return True

    def start_search(self, reverse=False):
        self.edit = ListSearcher('Search: ')
        urwid.connect_signal(self.edit, 'done', self.search_done, reverse)
        footer = urwid.Pile([urwid.Divider('\u2500'), self.edit])
        self.top.set_footer(footer)
        self.top.set_focus('footer')

    def search_done(self, pattern, reverse=False):
        logger.debug('Reverse: {}'.format(reverse))
        self.top.set_focus('body')
        urwid.disconnect_signal(self, self.edit, 'done', self.search_done)

        if pattern:
            logger.info('SEARCH FOR: {}'.format(pattern))
            found = self.list_view.search(pattern)

            if found:
                status = 'Found {} matches'.format(found)
            else:
                status = 'No items matching {}'.format(pattern)

            self.update_status(status)
        else:
            self.update_status('Idle')

    def suggestion_list(self):
        body = []
        for suggestion in self.suggestions:
            item = SelectableAlbum(suggestion)

            urwid.connect_signal(item, 'enqueue', self.enqueue_album,
                                 item.album)
            urwid.connect_signal(item, 'play', self.play_album, item.album)

            body.append(urwid.AttrMap(item, None, focus_map='reversed'))

        if not body:
            body = [urwid.Text('MPD database is empty')]

        albumlist = AlbumList(urwid.SimpleFocusListWalker(body))
        return albumlist
        #box = urwid.ListBox(urwid.SimpleFocusListWalker(body))
        #box._command_map = AlbumListCommands()
        #return box

    def main_loop(self):
        logger.info('Starting event loop')

        self.update_suggestions()
        # self.start_db_update()

        return urwid.MainLoop(self.top, palette=[('reversed', 'standout', '')],
                              unhandled_input=self.dispatch)


class AlbumListCommands(urwid.CommandMap):
    DEFAULT_BINDINGS = {
        'cursor up': ('k', 'up'),
        'cursor down': ('j', 'down'),
        'cursor left': ('h', 'left'),
        'cursor right': ('l', 'right'),
        'cursor page up': ('ctrl b', 'page up'),
        'cursor page down': ('ctrl f', 'page down'),
        'quit': ('q',),
        'update': ('u',),
        'reload': ('r',),
        GO_TO_TOP: ('g', 'home'),
        GO_TO_BOTTOM: ('G', 'end'),
        SEARCH_NEXT: ('n',),
        SEARCH_PREV: ('N',),
        ENQUEUE: (' ',),
        PLAY: ('enter',),
    }

    @classmethod
    def _flatten(cls, bindings):
        flattened = {}
        for action, keys in bindings.items():
            flattened.update({key: action for key in keys})

        return flattened

    def __init__(self, *args, **kwArgs):
        super(AlbumListCommands, self).__init__()
        self.update(self._flatten(self.DEFAULT_BINDINGS))
        self.update(*args, **kwArgs)

    def update(self, *args, **kwArgs):
        if args and isinstance(args[0], dict):
            bindings = args[0]
        else:
            bindings = kwArgs

        for key, command in bindings.items():
            self.__setitem__(key, command)


class AlbumSearcher(object):

    def __init__(self, pattern, items, current):
        self.pattern = pattern

        self.matches, self.match_index = self.search(items, current)

    def _order_items(self, items):
        raise NotImplementedError

    def _current_position(self, items, current):
        raise NotImplementedError

    def _indices(items):
        raise NotImplementedError

    def current_match(self):
        return self.matches[self.match_index]

    def search(self, items, current):
        current = self._current_position(items, current)
        items = self._order_items(items)

        ordered = chain(
            islice(items, current, None),
            islice(items, 0, current)
        )

        albums = (item.original_widget.album for item in ordered)
        search_items = ('{} - {}'.format(album.artist.name, album.name)
                        for album in albums)

        indices = self._indices(search_items)
        matches = [
            (current + index) % len(items) for index in indices
        ]

        if not matches:
            raise ValueError('No matches found')

        if matches[0] == current and len(matches) > 1:
            match_index = 1
        else:
            match_index = 0

        logger.debug('{} matches found'.format(len(matches)))

        return matches, match_index

    def find_closest_match(self, current, backward=False):
        if backward:
            return next(
                (len(self.matches) - idx - 1 for idx, position
                 in enumerate(reversed(self.matches))
                 if position < current),
                len(self.matches) - 1
            )
        else:
            return next(
                (idx for idx, position in enumerate(self.matches)
                 if position > current),
                0
            )

    def next_match(self, current, backward=False):
        if current != self.matches[self.match_index]:
            index = self.find_closest_match(current, backward=backward)
        else:
            index = self.match_index + (-1 if backward else 1)

        if index < 0:
            return len(self.matches) - 1
        elif index >= len(self.matches):
            return 0
        else:
            return index

    def next_search_item(self, current, backward=False):
        if not self.matches or self.match_index is None:
            logger.debug('No search found')
            return None

        index = self.next_match(current, backward=backward)
        return self.matches[index]

        #self.set_focus(self.matches[index])
        #self.match_index = index


class ForwardAlbumSearcher(AlbumSearcher):

    @classmethod
    def _order_items(self, items):
        return list(items)

    @classmethod
    def _current_position(self, _items, current):
        return current

    def _indices(self, items):
        return [
            i for i, item in enumerate(items)
            if re.search(self.pattern, item, re.I) is not None
        ]


class ReverseAlbumSearcher(AlbumSearcher):

    @classmethod
    def _order_items(self, items):
        return list(reversed(items))

    @classmethod
    def _current_position(self, items, current):
        return len(items) - current - 1

    def _indices(self, items):
        n_items = len(items)
        return [
            (n_items - i - 1) for i, item in enumerate(items)
            if re.search(self.pattern, item, re.I) is not None
        ]


class AlbumList(urwid.ListBox):

    def __init__(self, *args, **kwArgs):
        super(AlbumList, self).__init__(*args, **kwArgs)

        self._command_map = AlbumListCommands()
        self.searcher = None

    def search(self, pattern, reverse=False):
        self.searcher = None

        searcher = ReverseAlbumSearcher if reverse else ForwardAlbumSearcher

        try:
            self.searcher = searcher(
                pattern, self.body, self.focus_position)
            self.set_focus(self.searcher.current_match())
            return len(self.searcher.matches)
        except ValueError as err:
            logger.info('No matches found')
            logger.debug('Exception: {}'.format(err))
            return 0

    def next_search_item(self, backward=False):
        if self.searcher is None:
            logger.debug('No search found')
            return

        index = self.searcher.next_search_item(
            self.focus_position, backward=backward)

        self.set_focus(index)

    def keypress(self, size, key):
        cmd = self._command_map[key]
        if cmd in (SEARCH_NEXT, SEARCH_PREV):
            backward = (cmd == SEARCH_PREV)
            self.next_search_item(backward=backward)
        elif cmd in (GO_TO_TOP, GO_TO_BOTTOM):
            self.set_focus(0 if cmd == GO_TO_TOP else len(self.body) - 1)
        else:
            return super(AlbumList, self).keypress(size, key)

        # Necessary to get list focus to redraw
        super(AlbumList, self).keypress(size, None)

        return True


class SelectableAlbum(urwid.WidgetWrap):
    __metaclass__ = urwid.signals.MetaSignals
    signals = ['enqueue', 'play']

    def __init__(self, suggestion):
        self.album = album = suggestion.album
        #text = '{} - {} ({}/{} loved)'.format(
        #    album.artist.name, album.name, len(suggestion.loved),
        #    len(album.tracks))
        text = '{} - {}'.format(
            album.artist.name, album.name)
        super(SelectableAlbum, self).__init__(urwid.SelectableIcon(text))

        self._command_map = AlbumListCommands()

    def keypress(self, size, key):
        if self._command_map[key] == ENQUEUE:
            self._emit('enqueue')
        elif self._command_map[key] == PLAY:
            self._emit('play')
        else:
            return key


class ListSearcher(urwid.Edit):
    __metaclass__ = urwid.signals.MetaSignals
    signals = ['done']

    def keypress(self, size, key):
        if key == 'enter':
            urwid.emit_signal(self, 'done', self.get_edit_text())
        elif key == 'esc':
            urwid.emit_signal(self, 'done', None)
        else:
            super(ListSearcher, self).keypress(size, key)

        return True


def main():
    conf = mstat.configuration(path='suggestive.conf')

    logging.basicConfig(level=logging.DEBUG, filename='log.txt', filemode='w')
    logger.info('Starting event loop')

    app = Application(conf)

    app.event_loop.run()


if __name__ == '__main__':
    main()

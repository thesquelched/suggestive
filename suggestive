#! /usr/bin/python3

from threads import MpdWatchThread, DatabaseUpdateThread
from analytics import (
    Analytics, FractionLovedOrder, BannedOrder, ArtistFilter, AlbumFilter,
    SortOrder, PlaycountOrder, BaseOrder)
import mstat

import urwid
import shlex
import logging
from itertools import chain, islice
import re
from mpd import CommandError

logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())

# Keybinds
SEARCH_NEXT = 'search_next'
SEARCH_PREV = 'search_prev'
GO_TO_TOP = 'cursor max left'
GO_TO_BOTTOM = 'cursor max right'


COMMAND_KWARG_RGX = re.compile(r'^(\w+)=(.*?)$')


def album_text(album):
    return '{} - {}'.format(album.artist.name, album.name)

#
# Threads
#


class CommanderEdit(urwid.Edit):
    __metaclass__ = urwid.signals.MetaSignals
    signals = ['command_done']

    def keypress(self, size, key):
        if key == 'enter':
            urwid.emit_signal(self, 'command_done', self.get_edit_text())
        elif key == 'esc':
            urwid.emit_signal(self, 'command_done', None)
        else:
            super(CommanderEdit, self).keypress(size, key)

        return True


class Commandable(object):
    commands = {}

    @classmethod
    def parse_command_args(cls, args_raw):
        args = []
        kwargs = {}
        for arg in args_raw:
            match = re.search(COMMAND_KWARG_RGX, arg)
            if match is None:
                args.append(arg)
            else:
                name, value = match.groups()
                kwargs[name] = value

        return (args, kwargs)

    def execute_command(self, command_raw):
        pieces = shlex.split(command_raw)
        if not pieces:
            return

        command_name, args_raw = pieces[0], pieces[1:]
        if command_name in self.commands:
            args, kwargs = self.parse_command_args(args_raw)
            command_func = self.commands[command_name]
            command_func(*args, **kwargs)

            return True
        else:
            return False


class BufferList(object):

    def next_buffer(self):
        try:
            self.focus_position += 1
            while not isinstance(self.focus, Buffer):
                self.focus_position += 1

        except IndexError:
            self.focus_position = 0

    def add(self, buf, *options):
        self.contents.append((buf, self.options(*options)))

    def remove(self, buf):
        if len(self.contents) == 1:
            return False

        try:
            buffers = [item[0] for item in self.contents]
            idx = buffers.index(buf)
            self.contents.pop(idx)

            while not isinstance(self.focus, Buffer):
                self.contents.pop(idx)

            return True

        except ValueError:
            return False


class HorizontalBufferList(urwid.Pile, BufferList):
    pass


class VerticalBufferList(urwid.Columns, BufferList):

    def add(self, buf):
        if len(self.contents) > 0:
            fill = urwid.AttrMap(urwid.SolidFill(), 'status')
            super(VerticalBufferList, self).add(fill, 'given')
        super(VerticalBufferList, self).add(buf)


class Buffer(urwid.Frame, Commandable):
    __metaclass__ = urwid.signals.MetaSignals
    signals = ['set_footer', 'set_focus', 'set_status']

    def __init__(self, *args, **kwArgs):
        super(Buffer, self).__init__(*args, **kwArgs)
        self.bindings = self.setup_bindings()
        self.commands = self.setup_commands()
        self.active = False
        urwid.connect_signal(self, 'set_status', self.update_status)

    def update_status(self, value):
        if isinstance(value, str):
            status = urwid.Text(value)
        else:
            status = value

        footer = urwid.AttrMap(status, 'status')
        self.set_footer(footer)

    def update_focus(self, to_focus):
        urwid.emit_signal(self, 'set_focus', to_focus)

    def update_footer(self, footer, focus=False):
        urwid.emit_signal(self, 'set_footer', footer, focus)

    def setup_bindings(self):
        return {}

    def setup_commands(self):
        return {}

    def keypress(self, size, key):
        if not self.dispatch(key):
            return super(Buffer, self).keypress(size, key)

        super(Buffer, self).keypress(size, None)
        return True

    def dispatch(self, key):
        if key in self.bindings:
            func = self.bindings[key]
            logger.debug('KEYBIND: {}'.format(func))
            func()
            return True
        else:
            return False


class ListSearcher(urwid.Edit):
    __metaclass__ = urwid.signals.MetaSignals
    signals = ['search_done']

    def keypress(self, size, key):
        if key == 'enter':
            urwid.emit_signal(self, 'search_done', self.get_edit_text())
        elif key == 'esc':
            urwid.emit_signal(self, 'search_done', None)
        else:
            super(ListSearcher, self).keypress(size, key)

        return True


class LibraryBuffer(Buffer):
    signals = Buffer.signals + ['update_playlist']

    ORDERERS = {
        ('artist', 'ar'): ArtistFilter,
        ('album', 'al'): AlbumFilter,
        ('sort',): SortOrder,
        ('loved', 'lo'): FractionLovedOrder,
        ('banned', 'bn'): BannedOrder,
        ('pc', 'playcount'): PlaycountOrder,
    }

    def __init__(self, conf):
        self.conf = conf
        self.commands = self.setup_commands()

        self.default_orderers = [
            BaseOrder(),
            FractionLovedOrder(),
            BannedOrder()
        ]
        self.orderers = list(self.default_orderers)

        session = mstat.initialize_sqlalchemy(conf)
        self.anl = Analytics(session)

        self.suggestions = []

        self.search_matches = []
        self.current_search_index = None

        self.list_view = self.suggestion_list()

        super(LibraryBuffer, self).__init__(self.list_view)
        self.update_status('Library')

    def setup_commands(self):
        orderers = dict(
            chain.from_iterable(
                ((command, func) for command in commands)
                for commands, func in self.ORDERERS.items()
            )
        )

        return {
            name: self.orderer_func(orderer)
            for name, orderer in orderers.items()
        }

    def orderer_func(self, orderer):
        def add_func(*args, **kwArgs):
            self.add_orderer(orderer, *args, **kwArgs)
        return add_func

    def setup_bindings(self):
        return {
            '/': lambda: self.start_search(),
            'esc': lambda: self.reset_orderers(),
        }

    def suggestion_list(self):
        body = []
        for suggestion in self.suggestions:
            item = SelectableAlbum(suggestion)

            urwid.connect_signal(item, 'enqueue', self.enqueue_album)
            urwid.connect_signal(item, 'play', self.play_album)

            body.append(urwid.AttrMap(item, 'album', 'focus album'))

        if not body:
            body = [urwid.AttrMap(urwid.Text('No albums found'), 'album')]

        albumlist = AlbumList(self, urwid.SimpleFocusListWalker(body))
        return albumlist

    def update_suggestions(self, *_args):
        logger.info('Update suggestions display')
        self.suggestions = self.get_suggestions()

        self.list_view = self.suggestion_list()
        self.set_body(self.list_view)

        #self.update_status('suggestive')

    def get_suggestions(self):
        return self.anl.order_albums(self.orderers)

    def enqueue_album(self, album):
        self.enqueue_tracks(album.tracks)

    def play_album(self, album):
        self.play_tracks(album.tracks)

    def enqueue_track(self, track):
        self.enqueue_tracks([track])

    def play_track(self, track):
        self.play_tracks([track])

    def enqueue_tracks(self, tracks):
        mpd = mstat.initialize_mpd(self.conf)

        if tracks:
            logger.info('Enqueue {}'.format(album_text(tracks[0].album)))

        mpd_tracks = list(chain.from_iterable(
            mpd.listallinfo(track.filename) for track in tracks))

        for i, track in enumerate(mpd_tracks):
            trackno = str(track.get('track', i))
            trackno = re.sub(r'(\d+)/\d+', r'\1', trackno)
            track['track'] = int(trackno)

        sorted_tracks = sorted(mpd_tracks, key=lambda track: track['track'])
        ids = [mpd.addid(track['file']) for track in sorted_tracks]

        urwid.emit_signal(self, 'update_playlist')
        return ids

    def play_tracks(self, tracks):
        mpd = mstat.initialize_mpd(self.conf)

        if tracks:
            logger.info('Play: {}'.format(album_text(tracks[0].album)))

        mpd.clear()
        ids = self.enqueue_tracks(tracks)
        if ids:
            mpd.playid(ids[0])

    def start_search(self, reverse=False):
        self.edit = ListSearcher('/')
        urwid.connect_signal(self.edit, 'search_done', self.search_done,
                             reverse)
        footer = urwid.AttrMap(self.edit, 'footer')
        self.update_footer(footer)
        self.update_focus('footer')

    def search_done(self, pattern, reverse=False):
        logger.debug('Reverse: {}'.format(reverse))
        self.update_focus('body')
        urwid.disconnect_signal(self, self.edit, 'search_done',
                                self.search_done)

        if pattern:
            logger.info('SEARCH FOR: {}'.format(pattern))
            found = self.list_view.search(pattern)

            if found:
                status = 'Found {} matches'.format(found)
            else:
                status = 'No items matching {}'.format(pattern)

            self.update_status(status)

    def add_orderer(self, orderer_class, *args, **kwArgs):
        orderer = orderer_class(*args, **kwArgs)
        try:
            idx = list(map(type, self.orderers)).index(orderer)
            self.orderers[idx] = orderer
        except ValueError:
            self.orderers.append(orderer)

        logger.debug('Orderers: {}'.format(
            ', '.join(map(repr, self.orderers))))

        self.update_suggestions()

    def reset_orderers(self):
        logger.info('Clear modes')
        if self.orderers != self.default_orderers:
            self.orderers = list(self.default_orderers)

            self.update_suggestions()
        else:
            logger.debug('Modes are already at default')

        self.update_footer('suggestive')


class PlaylistView(urwid.ListBox):

    def __init__(self, *args, **kwArgs):
        super(PlaylistView, self).__init__(*args, **kwArgs)
        self._command_map = ListCommands()


class PlaylistBuffer(Buffer):
    ITEM_FORMAT = '{artist} - {album} - {title}'

    def __init__(self, conf):
        self.conf = conf

        self.format_keys = re.findall(r'\{(\w+)\}', self.ITEM_FORMAT)
        walker = urwid.SimpleFocusListWalker(self.playlist_items())
        self.playlist = PlaylistView(walker)
        super(PlaylistBuffer, self).__init__(self.playlist)

        self.update_status('Playlist')

    def setup_bindings(self):
        return {
            'c': self.clear_mpd_playlist,
            'd': self.delete_track,
            'enter': self.play_track,
        }

    def delete_track(self):
        current_position = self.playlist.focus_position

        if current_position is not None:
            mpd = mstat.initialize_mpd(self.conf)
            mpd.delete(current_position)

            self.update()

    def play_track(self):
        current_position = self.playlist.focus_position

        if current_position is not None:
            mpd = mstat.initialize_mpd(self.conf)
            mpd.play(current_position)

            self.update()

    def format_track(self, track):
        replace = {key: 'Unknown' for key in self.format_keys}
        replace.update(track)

        return self.ITEM_FORMAT.format(**replace)

    def playlist_items(self):
        mpd = mstat.initialize_mpd(self.conf)

        playlist = mpd.playlistinfo()
        current = mpd.currentsong()
        if current and 'pos' in current:
            current_position = int(current['pos'])
        else:
            current_position = None

        body = []
        for position, track in enumerate(playlist):
            text = urwid.SelectableIcon(self.format_track(track))
            if position == current_position:
                styles = ('playing', 'playing focus')
            else:
                styles = ('playlist', 'focus playlist')

            with_attr = urwid.AttrMap(text, *styles)
            body.append(with_attr)

        if not body:
            text = urwid.Text('Playlist is empty')
            body.append(urwid.AttrMap(text, 'playlist'))

        return body

    def update(self, *args):
        current_position = self.playlist.focus_position

        items = self.playlist_items()

        self.clear_playlist()
        self.playlist.body.extend(items)

        try:
            self.playlist.focus_position = current_position
        except IndexError:
            try:
                self.playlist.focus_position = current_position - 1
            except IndexError:
                return

    def clear_playlist(self):
        del self.playlist.body[:]

    def clear_mpd_playlist(self):
        logger.debug('clearing list')

        mpd = mstat.initialize_mpd(self.conf)
        mpd.stop()
        mpd.clear()

        self.update()


class MainWindow(urwid.Frame):
    __metaclass__ = urwid.signals.MetaSignals
    signals = ['set_footer', 'set_focus']

    def __init__(self, conf, *args, **kwArgs):
        super(MainWindow, self).__init__(*args, **kwArgs)
        self.conf = conf

        # Signals
        #urwid.connect_signal(self, 'set_status', self.update_status)
        urwid.connect_signal(self, 'set_footer', self.update_footer)
        urwid.connect_signal(self, 'set_focus', self.update_focus)

    def update_footer(self, footer, focus=False):
        self.set_footer(footer)
        if focus:
            self.set_focus('footer')

    def update_focus(self, to_focus):
        self.set_focus(to_focus)

    #def update_status(self, text, error=False):
    #    status = urwid.Text(text)
    #    footer = urwid.AttrMap(status, 'status error' if error else 'status')

    #    self.set_footer(footer)


class Application(Commandable):
    def __init__(self, conf):
        self.conf = conf
        self.default_orderers = [
            BaseOrder(),
            FractionLovedOrder(),
            BannedOrder()
        ]
        self.orderers = list(self.default_orderers)

        self.bindings = self.setup_bindings()
        self.commands = self.setup_commands()

        session = mstat.initialize_sqlalchemy(conf)
        self.anl = Analytics(session)

        self.suggestions = []

        self.search_matches = []
        self.current_search_index = None

        self.orientation = self.conf.orientation()

        if self.orientation == 'vertical':
            self.buffers = VerticalBufferList([])
        else:
            self.buffers = HorizontalBufferList([])

        self.top = MainWindow(conf, self.buffers)
        self.event_loop = self.main_loop()

        # Initialize buffers
        self.library_buffer = self.create_library_buffer()
        self.playlist_buffer = self.create_playlist_buffer()

        urwid.connect_signal(
            self.library_buffer,
            'update_playlist',
            self.playlist_buffer.update)
        self.setup_buffers()

        self.update_footer_text('suggestive')

    def setup_buffers(self):
        default_buffers = self.conf.default_buffers()

        if 'library' in default_buffers:
            self.buffers.add(self.library_buffer)
            self.library_buffer.active = True
        if 'playlist' in default_buffers:
            self.buffers.add(self.playlist_buffer)
            self.playlist_buffer.active = True

    def change_orientation(self, orientation=None):
        if orientation is None:
            orientation = ('vertical' if self.orientation == 'horizontal'
                           else 'horizontal')

        if orientation == 'vertical':
            buffers = VerticalBufferList([])
        else:
            buffers = HorizontalBufferList([])

        if self.library_buffer.active:
            buffers.add(self.library_buffer)
        if self.playlist_buffer.active:
            buffers.add(self.playlist_buffer)

        self.orientation = orientation
        self.buffers = buffers
        self.top.body = self.buffers

    def update_footer(self, value, error=False):
        if isinstance(value, str):
            self.update_footer_text(value, error=error)
        else:
            self.top.update_footer(value)

    def update_footer_text(self, value, error=False):
        text = urwid.AttrMap(
            urwid.Text(value),
            'footer error' if error else 'footer'
        )
        self.top.update_footer(text)

    def create_library_buffer(self):
        buf = LibraryBuffer(self.conf)
        urwid.connect_signal(buf, 'set_focus', self.top.update_focus)
        urwid.connect_signal(buf, 'set_footer', self.update_footer)

        buf.update_suggestions()

        return buf

    def create_playlist_buffer(self):
        buf = PlaylistBuffer(self.conf)
        urwid.connect_signal(buf, 'set_focus', self.top.update_focus)
        urwid.connect_signal(buf, 'set_footer', self.update_footer)

        return buf

    def open_playlist(self):
        if self.playlist_buffer.active:
            logger.debug('Close playlist')
            if self.buffers.remove(self.playlist_buffer):
                self.playlist_buffer.active = False
        else:
            logger.debug('Open playlist')
            self.buffers.add(self.playlist_buffer)
            self.playlist_buffer.active = True

    def open_library(self):
        if self.library_buffer.active:
            logger.debug('Close playlist')
            if self.buffers.remove(self.library_buffer):
                self.library_buffer.active = False
        else:
            logger.debug('Open playlist')
            self.buffers.add(self.library_buffer)
            self.library_buffer.active = True

    def start_db_update(self):
        #self.update_status('Updating database')
        update_thread = DatabaseUpdateThread(
            self.conf, self.update_library_event)
        update_thread.daemon = False
        update_thread.start()

    def start_mpd_watch_thread(self):
        #self.update_status('Updating database')
        thread = MpdWatchThread(
            self.conf,
            self.update_playlist_event)
        thread.daemon = True
        thread.start()

    def update_library_event(self):
        self.event_loop.set_alarm_in(0, self.library_buffer.update_suggestions)

    def update_playlist_event(self):
        self.playlist_buffer.update()

    def dispatch(self, key):
        if key in self.bindings:
            func = self.bindings[key]
            logger.debug('KEYBIND: {}'.format(func))
            func()
            return True
        else:
            return False

    @classmethod
    def exit(cls):
        raise urwid.ExitMainLoop()

    def setup_bindings(self):
        return {
            'q': lambda: self.exit(),
            'u': lambda: self.start_db_update(),
            ':': lambda: self.start_command(),
            'p': lambda: self.pause(),
            'ctrl w': lambda: self.buffers.next_buffer()
        }

    def setup_commands(self):
        return {
            'playlist': self.open_playlist,
            'library': self.open_library,
            'q': self.exit,
            'orientation': self.change_orientation,
        }

    def pause(self):
        mpd = mstat.initialize_mpd(self.conf)
        mpd.pause()

    def start_command(self):
        self.edit = CommanderEdit(':')
        urwid.connect_signal(self.edit, 'command_done', self.command_done)
        footer = urwid.AttrMap(self.edit, 'footer')
        self.top.set_footer(footer)
        self.top.set_focus('footer')

    def command_done(self, command):
        self.top.set_focus('body')
        urwid.disconnect_signal(self, self.edit, 'command_done',
                                self.command_done)

        if command:
            success = False

            try:
                success = self.buffers.focus.execute_command(command)
                if not success:
                    success = self.execute_command(command)
            except TypeError as err:
                logger.debug('TypeError: {}'.format(err))
                raise
                self.update_footer_text(
                    "Invalid arguments for command '{}'".format(command),
                    error=True)

            if not success:
                self.update_footer_text(
                    "Unknown command: '{}'".format(command),
                    error=True)

    def setup_palette(self):
        return self.conf.palette()

    def setup_term(self, screen):
        colormode = 256 if self.conf.use_256_colors() else 88
        screen.set_terminal_properties(colors=colormode)

    def main_loop(self):
        logger.info('Starting event loop')

        mainloop = urwid.MainLoop(
            self.top,
            palette=self.setup_palette(),
            unhandled_input=self.dispatch,
            handle_mouse=False,
        )

        self.setup_term(mainloop.screen)

        # Start threads
        self.start_mpd_watch_thread()

        return mainloop


class ListCommands(urwid.CommandMap):
    DEFAULT_BINDINGS = {
        'cursor up': ('k', 'up'),
        'cursor down': ('j', 'down'),
        'cursor left': ('h', 'left'),
        'cursor right': ('l', 'right'),
        'cursor page up': ('ctrl b', 'page up'),
        'cursor page down': ('ctrl f', 'page down'),

        GO_TO_TOP: ('g', 'home'),
        GO_TO_BOTTOM: ('G', 'end'),
    }

    @classmethod
    def _flatten(cls, bindings):
        flattened = {}
        for action, keys in bindings.items():
            flattened.update({key: action for key in keys})

        return flattened

    def __init__(self, *args, **kwArgs):
        super(ListCommands, self).__init__()
        self.update(self._flatten(self.DEFAULT_BINDINGS))
        self.update(*args, **kwArgs)

    def update(self, *args, **kwArgs):
        if args and isinstance(args[0], dict):
            bindings = args[0]
        else:
            bindings = kwArgs

        for key, command in bindings.items():
            self.__setitem__(key, command)


class AlbumListCommands(urwid.CommandMap):
    DEFAULT_BINDINGS = {
        'cursor up': ('k', 'up'),
        'cursor down': ('j', 'down'),
        'cursor left': ('h', 'left'),
        'cursor right': ('l', 'right'),
        'cursor page up': ('ctrl b', 'page up'),
        'cursor page down': ('ctrl f', 'page down'),
        'quit': ('q',),
        'update': ('u',),
        'reload': ('r',),

        GO_TO_TOP: ('g', 'home'),
        GO_TO_BOTTOM: ('G', 'end'),
        SEARCH_NEXT: ('n',),
        SEARCH_PREV: ('N',),

        'enqueue': (' ',),
        'play': ('enter',),
        'expand': ('z',),
    }

    @classmethod
    def _flatten(cls, bindings):
        flattened = {}
        for action, keys in bindings.items():
            flattened.update({key: action for key in keys})

        return flattened

    def __init__(self, *args, **kwArgs):
        super(AlbumListCommands, self).__init__()
        self.update(self._flatten(self.DEFAULT_BINDINGS))
        self.update(*args, **kwArgs)

    def update(self, *args, **kwArgs):
        if args and isinstance(args[0], dict):
            bindings = args[0]
        else:
            bindings = kwArgs

        for key, command in bindings.items():
            self.__setitem__(key, command)


class AlbumSearcher(object):

    def __init__(self, pattern, items, current):
        self.pattern = pattern

        self.matches, self.match_index = self.search(items, current)

    def _order_items(self, items):
        raise NotImplementedError

    def _current_position(self, items, current):
        raise NotImplementedError

    def _indices(items):
        raise NotImplementedError

    def current_match(self):
        return self.matches[self.match_index]

    def search(self, items, current):
        current = self._current_position(items, current)
        items = self._order_items(items)

        ordered = chain(
            islice(items, current, None),
            islice(items, 0, current)
        )

        albums = (item.original_widget.album for item in ordered)
        search_items = (album_text(album) for album in albums)

        indices = self._indices(search_items)
        matches = [
            (current + index) % len(items) for index in indices
        ]

        if not matches:
            raise ValueError('No matches found')

        if matches[0] == current and len(matches) > 1:
            match_index = 1
        else:
            match_index = 0

        logger.debug('{} matches found'.format(len(matches)))

        return matches, match_index

    def find_closest_match(self, current, backward=False):
        if backward:
            return next(
                (len(self.matches) - idx - 1 for idx, position
                 in enumerate(reversed(self.matches))
                 if position < current),
                len(self.matches) - 1
            )
        else:
            return next(
                (idx for idx, position in enumerate(self.matches)
                 if position > current),
                0
            )

    def next_match(self, current, backward=False):
        if current != self.matches[self.match_index]:
            index = self.find_closest_match(current, backward=backward)
        else:
            index = self.match_index + (-1 if backward else 1)

        if index < 0:
            return len(self.matches) - 1
        elif index >= len(self.matches):
            return 0
        else:
            return index

    def next_search_item(self, current, backward=False):
        if not self.matches or self.match_index is None:
            logger.debug('No search found')
            return None

        index = self.next_match(current, backward=backward)
        return self.matches[index]


class ForwardAlbumSearcher(AlbumSearcher):

    @classmethod
    def _order_items(self, items):
        return list(items)

    @classmethod
    def _current_position(self, _items, current):
        return current

    def _indices(self, items):
        return [
            i for i, item in enumerate(items)
            if re.search(self.pattern, item, re.I) is not None
        ]


class ReverseAlbumSearcher(AlbumSearcher):

    @classmethod
    def _order_items(self, items):
        return list(reversed(items))

    @classmethod
    def _current_position(self, items, current):
        return len(items) - current - 1

    def _indices(self, items):
        n_items = len(items)
        return [
            (n_items - i - 1) for i, item in enumerate(items)
            if re.search(self.pattern, item, re.I) is not None
        ]


class AlbumList(urwid.ListBox):

    def __init__(self, app, *args, **kwArgs):
        super(AlbumList, self).__init__(*args, **kwArgs)

        self.app = app
        self.searcher = None

        self._command_map = AlbumListCommands()

    def search(self, pattern, reverse=False):
        self.searcher = None

        searcher = ReverseAlbumSearcher if reverse else ForwardAlbumSearcher

        try:
            self.searcher = searcher(
                pattern, self.body, self.focus_position)
            self.set_focus(self.searcher.current_match())
            return len(self.searcher.matches)
        except ValueError as err:
            logger.info('No matches found')
            logger.debug('Exception: {}'.format(err))
            return 0

    def next_search_item(self, backward=False):
        if self.searcher is None:
            logger.debug('No search found')
            return

        index = self.searcher.next_search_item(
            self.focus_position, backward=backward)

        self.set_focus(index)

    def sort_tracks(self, tracks):
        track_and_num = []
        mpd = mstat.initialize_mpd(self.app.conf)

        for i, track in enumerate(tracks):
            try:
                mpd_track = mpd.listallinfo(track.filename)
            except CommandError:
                continue

            if not mpd_track:
                continue
            trackno = str(mpd_track[0].get('track', i))
            trackno = re.sub(r'(\d+)/\d+', r'\1', trackno)

            track_and_num.append((int(trackno), track))

        logger.debug('Track nums: {}'.format([x[0] for x in track_and_num]))

        return sorted(track_and_num, key=lambda pair: pair[0])

    def expand_album(self, album_widget):
        current = self.focus_position
        album = album_widget.original_widget.album

        sorted_tracks = self.sort_tracks(album.tracks)
        for track_no, track in reversed(sorted_tracks):
            track_widget = SelectableTrack(album_widget, track, track_no)

            urwid.connect_signal(track_widget, 'enqueue',
                                 self.app.enqueue_track)
            urwid.connect_signal(track_widget, 'play', self.app.play_track)

            item = urwid.AttrMap(track_widget, 'track', 'focus track')
            self.body.insert(current + 1, item)

        album_widget.original_widget.expanded = True
        #self.body.insert(current + 1, self.focus)

    def collapse_album(self, album_widget):
        current = self.focus_position
        album_index = self.body.index(album_widget, 0, current + 1)

        logger.debug('Album index: {}'.format(album_index))

        album = album_widget.original_widget.album
        for i in range(len(album.tracks)):
            track_widget = self.body[album_index + 1]
            if isinstance(track_widget.original_widget, SelectableTrack):
                self.body.pop(album_index + 1)
            else:
                logger.error('Item #{} is not a track'.format(i))

        album_widget.original_widget.expanded = False

    def toggle_expand(self):
        widget = self.focus

        if isinstance(widget.original_widget, SelectableTrack):
            widget = widget.original_widget.parent

        if widget.original_widget.expanded:
            self.collapse_album(widget)
        else:
            self.expand_album(widget)

        album = widget.original_widget.album

        logger.info('Expand: {} ({} tracks)'.format(
            album_text(album),
            len(album.tracks)))

    def keypress(self, size, key):
        cmd = self._command_map[key]
        if cmd in (SEARCH_NEXT, SEARCH_PREV):
            backward = (cmd == SEARCH_PREV)
            self.next_search_item(backward=backward)
        elif cmd in (GO_TO_TOP, GO_TO_BOTTOM):
            self.set_focus(0 if cmd == GO_TO_TOP else len(self.body) - 1)
        elif cmd == 'expand':
            self.toggle_expand()
        else:
            return super(AlbumList, self).keypress(size, key)

        # Necessary to get list focus to redraw
        super(AlbumList, self).keypress(size, None)

        return True


class SelectableAlbum(urwid.WidgetWrap):
    __metaclass__ = urwid.signals.MetaSignals
    signals = ['enqueue', 'play']

    def __init__(self, suggestion):
        self.album = album = suggestion.album
        self.expanded = False
        text = album_text(album)
        super(SelectableAlbum, self).__init__(urwid.SelectableIcon(text))

        self._command_map = AlbumListCommands()

    def keypress(self, size, key):
        if self._command_map[key] == 'enqueue':
            urwid.emit_signal(self, 'enqueue', self.album)
        elif self._command_map[key] == 'play':
            urwid.emit_signal(self, 'play', self.album)
        else:
            return key


class SelectableTrack(urwid.WidgetWrap):
    __metaclass__ = urwid.signals.MetaSignals
    signals = ['enqueue', 'play']

    def __init__(self, parent, track, track_no):
        self.parent = parent
        self.track = track
        self.track_no = track_no
        text = ' + {} - {}'.format(track_no, track.name)
        super(SelectableTrack, self).__init__(urwid.SelectableIcon(text))

        self._command_map = AlbumListCommands()

    def keypress(self, size, key):
        if self._command_map[key] == 'enqueue':
            urwid.emit_signal(self, 'enqueue', self.track)
        elif self._command_map[key] == 'play':
            urwid.emit_signal(self, 'play', self.track)
        else:
            return key


def main():
    conf = mstat.configuration(path='suggestive.conf')

    logging.basicConfig(level=logging.DEBUG, filename='log.txt', filemode='w')
    logger.info('Starting event loop')

    app = Application(conf)

    try:
        app.event_loop.run()
    except KeyboardInterrupt:
        logger.error("Exited via keyboard interrupt; next time, use 'q'")


if __name__ == '__main__':
    main()

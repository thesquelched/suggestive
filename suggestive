#! /usr/bin/python3

import urwid
import shlex
import logging
import threading
import mstat
from analytics import (
    Analytics, FractionLovedOrder, BannedOrder, ArtistFilter, AlbumFilter,
    SortOrder, PlaycountOrder, BaseOrder)
from datetime import datetime
from subprocess import call
from itertools import chain, islice
import re

logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())

# Keybinds
SEARCH_NEXT = 'search_next'
SEARCH_PREV = 'search_prev'
GO_TO_TOP = 'cursor max left'
GO_TO_BOTTOM = 'cursor max right'

# Commands
FILTERS = {
    ('artist', 'ar'): ArtistFilter,
    ('album', 'al'): AlbumFilter,
    ('sort',): SortOrder,
    ('loved', 'lo'): FractionLovedOrder,
    ('banned', 'bn'): BannedOrder,
    ('pc', 'playcount'): PlaycountOrder,
}

# Create a flat dict from FILTERS in which the commands in the tuple key
# correspond to the filter value
FILTER_COMMANDS = dict(
    chain.from_iterable(
        [(command, func) for command in commands]
        for commands, func in FILTERS.items()
    )
)

COMMAND_KWARG_RGX = re.compile(r'^(\w+)=(.*?)$')


def album_text(album):
    return '{} - {}'.format(album.artist.name, album.name)

#
# Threads
#


class AppThread(threading.Thread):
    pass


class DatabaseUpdateThread(AppThread):

    def __init__(self, conf, callback, *args, **kwArgs):
        super(DatabaseUpdateThread, self).__init__(*args, **kwArgs)
        self.callback = callback
        self.conf = conf

        self.session = mstat.initialize_sqlalchemy(conf)
        self.mpd = mstat.initialize_mpd(conf)
        self.lastfm = mstat.initialize_lastfm(conf)

    def run(self):
        logger.info('Start MPD update')
        self.mpd.update()
        logger.info('Finished MPD update')
        logger.info('Update internal database')
        mstat.update_database(self.session, self.mpd, self.lastfm, self.conf)
        self.session.close()
        logger.info('Finished update')
        (self.callback)()


class Commandable(object):
    def __init__(self):
        self.edit = None

    def start_command(self):
        self.edit = CommanderEdit(':')
        urwid.connect_signal(self.edit, 'command_done', self.command_done)
        footer = urwid.AttrMap(self.edit, 'status')
        urwid.emit_signal(self, 'set_footer', footer, True)
        #self.top.set_footer(footer)
        #self.top.set_focus('footer')

    def command_done(self, command):
        #self.top.set_focus('body')
        urwid.emit_signal(self, 'set_focus', 'body')
        urwid.disconnect_signal(self, self.edit, 'command_done',
                                self.command_done)

        if command:
            self.execute_command(command)

    @classmethod
    def parse_command_args(cls, args_raw):
        args = []
        kwargs = {}
        for arg in args_raw:
            match = re.search(COMMAND_KWARG_RGX, arg)
            if match is None:
                args.append(arg)
            else:
                name, value = match.groups()
                kwargs[name] = value

        return (args, kwargs)

    def execute_command(self, command_raw):
        pieces = shlex.split(command_raw)
        if not pieces:
            return

        command_name, args_raw = pieces[0], pieces[1:]


class MainWindow(urwid.Frame):
    __metaclass__ = urwid.signals.MetaSignals
    signals = ['set_footer', 'set_focus', 'set_status', 'set_header']

    def __init__(self, conf, *args, **kwArgs):
        super(MainWindow, self).__init__(*args, **kwArgs)
        self.conf = conf

        # Signals
        urwid.connect_signal(self, 'set_status', self.update_status)
        urwid.connect_signal(self, 'set_header', self.update_header)
        urwid.connect_signal(self, 'set_footer', self.update_footer)
        urwid.connect_signal(self, 'set_focus', self.update_focus)

    def update_footer(self, footer, focus=False):
        self.set_footer(footer)
        if focus:
            self.set_focus('footer')

    def update_focus(self, to_focus):
        self.set_focus(to_focus)

    def update_status(self, text, error=False):
        status = urwid.Text(text)
        footer = urwid.AttrMap(status, 'status error' if error else 'status')

        self.set_footer(footer)

    def update_header(self, last_updated):
        timestamp = last_updated.strftime('%Y-%m-%d %H:%M:%S')
        upd = urwid.Text('Last updated: {}'.format(timestamp))
        header = urwid.AttrMap(upd, 'header')

        self.set_header(header)


class Application(object):

    def __init__(self, conf):
        self.conf = conf
        self.default_orderers = [
            BaseOrder(),
            FractionLovedOrder(),
            BannedOrder()
        ]
        self.orderers = list(self.default_orderers)

        self.bindings = self.setup_bindings()

        session = mstat.initialize_sqlalchemy(conf)
        self.anl = Analytics(session)

        self.suggestions = []

        self.search_matches = []
        self.current_search_index = None

        # urwid stuff
        self.list_view = self.suggestion_list()

        #self.top = urwid.Frame(self.list_view)
        self.top = MainWindow(conf, self.list_view)

        self.event_loop = self.main_loop()

    def start_db_update(self):
        self.update_status('Updating database')
        update_thread = DatabaseUpdateThread(self.conf, self.update_event)
        update_thread.daemon = False
        update_thread.start()

    def update_event(self):
        self.event_loop.set_alarm_in(0, self.update_suggestions)

    def update_suggestions(self, *_args):
        logger.info('Update suggestions display')
        self.suggestions = self.get_suggestions()

        self.list_view = self.suggestion_list()
        self.top.set_body(self.list_view)

        self.update_status('suggestive')
        self.update_header()

    def get_suggestions(self):
        return self.anl.order_albums(self.orderers)
        #return self.anl.loved_order()
        # return []
        #return self.anl.suggest_albums()

    def enqueue_album(self, album):
        self.enqueue_tracks(album.tracks)

    def play_album(self, album):
        self.play_tracks(album.tracks)

    def enqueue_track(self, track):
        self.enqueue_tracks([track])

    def play_track(self, track):
        self.play_tracks([track])

    def enqueue_tracks(self, tracks):
        mpd = mstat.initialize_mpd(self.conf)

        if tracks:
            logger.info('Enqueue {}'.format(album_text(tracks[0].album)))

        mpd_tracks = list(chain.from_iterable(
            mpd.listallinfo(track.filename) for track in tracks))

        for i, track in enumerate(mpd_tracks):
            trackno = str(track.get('track', i))
            trackno = re.sub(r'(\d+)/\d+', r'\1', trackno)
            track['track'] = int(trackno)

        sorted_tracks = sorted(mpd_tracks, key=lambda track: track['track'])
        ids = [mpd.addid(track['file']) for track in sorted_tracks]
        return ids

    def play_tracks(self, tracks):
        mpd = mstat.initialize_mpd(self.conf)

        if tracks:
            logger.info('Play: {}'.format(album_text(tracks[0].album)))

        mpd.clear()
        ids = self.enqueue_tracks(tracks)
        if ids:
            mpd.playid(ids[0])

    def update_header(self):
        now = datetime.now()
        urwid.emit_signal(self.top, 'set_header', now)
        #timestamp = last_updated.strftime('%Y-%m-%d %H:%M:%S')
        #upd = urwid.Text('Last updated: {}'.format(timestamp))
        #header = urwid.AttrMap(upd, 'header')
        #self.top.set_header(header)

    def update_status(self, status, error=False):
        urwid.emit_signal(self.top, 'set_status', status, error)

    def dispatch(self, key):
        if key in self.bindings:
            func = self.bindings[key]
            logger.debug('KEYBIND: {}'.format(func))
            func()
            return True
        else:
            return False

    @classmethod
    def exit(cls):
        raise urwid.ExitMainLoop()

    def launch_mpd_client(self):
        self.event_loop.screen.stop()
        call(self.conf.mpd_client(), shell=True)
        self.event_loop.screen.start()

    def setup_bindings(self):
        return {
            'q': lambda: self.exit(),
            'u': lambda: self.start_db_update(),
            'r': lambda: self.update_suggestions(),
            '~': lambda: self.launch_mpd_client(),
            '/': lambda: self.start_search(),
            '?': lambda: self.start_search(reverse=True),
            ':': lambda: self.start_command(),
            'esc': lambda: self.reset_orderers(),
            'p': lambda: self.pause(),
        }

    def pause(self):
        mpd = mstat.initialize_mpd(self.conf)
        mpd.pause()

    def start_search(self, reverse=False):
        self.edit = ListSearcher('/')
        urwid.connect_signal(self.edit, 'search_done', self.search_done,
                             reverse)
        footer = urwid.AttrMap(self.edit, 'status')
        self.top.set_footer(footer)
        self.top.set_focus('footer')

    def search_done(self, pattern, reverse=False):
        logger.debug('Reverse: {}'.format(reverse))
        self.top.set_focus('body')
        urwid.disconnect_signal(self, self.edit, 'search_done',
                                self.search_done)

        if pattern:
            logger.info('SEARCH FOR: {}'.format(pattern))
            found = self.list_view.search(pattern)

            if found:
                status = 'Found {} matches'.format(found)
            else:
                status = 'No items matching {}'.format(pattern)

            self.update_status(status)

    def start_command(self):
        self.edit = CommanderEdit(':')
        urwid.connect_signal(self.edit, 'command_done', self.command_done)
        footer = urwid.AttrMap(self.edit, 'status')
        self.top.set_footer(footer)
        self.top.set_focus('footer')

    def command_done(self, command):
        self.top.set_focus('body')
        urwid.disconnect_signal(self, self.edit, 'command_done',
                                self.command_done)

        if command:
            self.execute_command(command)

    @classmethod
    def parse_command_args(cls, args_raw):
        args = []
        kwargs = {}
        for arg in args_raw:
            match = re.search(COMMAND_KWARG_RGX, arg)
            if match is None:
                args.append(arg)
            else:
                name, value = match.groups()
                kwargs[name] = value

        return (args, kwargs)

    def execute_command(self, command_raw):
        logger.info('COMMAND: {}'.format(command_raw))
        pieces = command_raw.split(' ', 1)
        command, args_raw = pieces[0], pieces[1:]

        if command in FILTER_COMMANDS:
            orderer = FILTER_COMMANDS[command]
            args, kwargs = self.parse_command_args(args_raw)

            try:
                fltr = orderer(*args, **kwargs)
                self.orderers.append(fltr)
                logger.debug('Orderers: {}'.format(
                    ', '.join(map(repr, self.orderers))))
            except TypeError as err:
                logger.debug('TypeError: {}'.format(err))
                self.update_status(
                    "Invalid arguments for command '{}'".format(command),
                    error=True)
                return
        else:
            self.update_status(
                "Unknown command: '{}'".format(command),
                error=True)
            return

        self.update_suggestions()

    def reset_orderers(self):
        logger.info('Clear modes')
        if self.orderers != self.default_orderers:
            self.orderers = list(self.default_orderers)

            self.update_suggestions()
        else:
            logger.debug('Modes are already at default')

    def suggestion_list(self):
        body = []
        for suggestion in self.suggestions:
            item = SelectableAlbum(suggestion)

            urwid.connect_signal(item, 'enqueue', self.enqueue_album)
            urwid.connect_signal(item, 'play', self.play_album)

            body.append(urwid.AttrMap(item, 'album', 'focus album'))

        if not body:
            body = [urwid.AttrMap(urwid.Text('No albums found'), 'album')]

        albumlist = AlbumList(self, urwid.SimpleFocusListWalker(body))
        return albumlist

    def setup_palette(self):
        return self.conf.palette()

    def setup_term(self, screen):
        colormode = 256 if self.conf.use_256_colors() else 88
        screen.set_terminal_properties(colors=colormode)

    def main_loop(self):
        logger.info('Starting event loop')

        self.update_suggestions()
        # self.start_db_update()

        mainloop = urwid.MainLoop(
            self.top,
            palette=self.setup_palette(),
            unhandled_input=self.dispatch,
            handle_mouse=False,
        )

        self.setup_term(mainloop.screen)

        return mainloop


class AlbumListCommands(urwid.CommandMap):
    DEFAULT_BINDINGS = {
        'cursor up': ('k', 'up'),
        'cursor down': ('j', 'down'),
        'cursor left': ('h', 'left'),
        'cursor right': ('l', 'right'),
        'cursor page up': ('ctrl b', 'page up'),
        'cursor page down': ('ctrl f', 'page down'),
        'quit': ('q',),
        'update': ('u',),
        'reload': ('r',),

        GO_TO_TOP: ('g', 'home'),
        GO_TO_BOTTOM: ('G', 'end'),
        SEARCH_NEXT: ('n',),
        SEARCH_PREV: ('N',),

        'enqueue': (' ',),
        'play': ('enter',),
        'expand': ('z',),
    }

    @classmethod
    def _flatten(cls, bindings):
        flattened = {}
        for action, keys in bindings.items():
            flattened.update({key: action for key in keys})

        return flattened

    def __init__(self, *args, **kwArgs):
        super(AlbumListCommands, self).__init__()
        self.update(self._flatten(self.DEFAULT_BINDINGS))
        self.update(*args, **kwArgs)

    def update(self, *args, **kwArgs):
        if args and isinstance(args[0], dict):
            bindings = args[0]
        else:
            bindings = kwArgs

        for key, command in bindings.items():
            self.__setitem__(key, command)


class AlbumSearcher(object):

    def __init__(self, pattern, items, current):
        self.pattern = pattern

        self.matches, self.match_index = self.search(items, current)

    def _order_items(self, items):
        raise NotImplementedError

    def _current_position(self, items, current):
        raise NotImplementedError

    def _indices(items):
        raise NotImplementedError

    def current_match(self):
        return self.matches[self.match_index]

    def search(self, items, current):
        current = self._current_position(items, current)
        items = self._order_items(items)

        ordered = chain(
            islice(items, current, None),
            islice(items, 0, current)
        )

        albums = (item.original_widget.album for item in ordered)
        search_items = (album_text(album) for album in albums)

        indices = self._indices(search_items)
        matches = [
            (current + index) % len(items) for index in indices
        ]

        if not matches:
            raise ValueError('No matches found')

        if matches[0] == current and len(matches) > 1:
            match_index = 1
        else:
            match_index = 0

        logger.debug('{} matches found'.format(len(matches)))

        return matches, match_index

    def find_closest_match(self, current, backward=False):
        if backward:
            return next(
                (len(self.matches) - idx - 1 for idx, position
                 in enumerate(reversed(self.matches))
                 if position < current),
                len(self.matches) - 1
            )
        else:
            return next(
                (idx for idx, position in enumerate(self.matches)
                 if position > current),
                0
            )

    def next_match(self, current, backward=False):
        if current != self.matches[self.match_index]:
            index = self.find_closest_match(current, backward=backward)
        else:
            index = self.match_index + (-1 if backward else 1)

        if index < 0:
            return len(self.matches) - 1
        elif index >= len(self.matches):
            return 0
        else:
            return index

    def next_search_item(self, current, backward=False):
        if not self.matches or self.match_index is None:
            logger.debug('No search found')
            return None

        index = self.next_match(current, backward=backward)
        return self.matches[index]


class ForwardAlbumSearcher(AlbumSearcher):

    @classmethod
    def _order_items(self, items):
        return list(items)

    @classmethod
    def _current_position(self, _items, current):
        return current

    def _indices(self, items):
        return [
            i for i, item in enumerate(items)
            if re.search(self.pattern, item, re.I) is not None
        ]


class ReverseAlbumSearcher(AlbumSearcher):

    @classmethod
    def _order_items(self, items):
        return list(reversed(items))

    @classmethod
    def _current_position(self, items, current):
        return len(items) - current - 1

    def _indices(self, items):
        n_items = len(items)
        return [
            (n_items - i - 1) for i, item in enumerate(items)
            if re.search(self.pattern, item, re.I) is not None
        ]


class AlbumList(urwid.ListBox):

    def __init__(self, app, *args, **kwArgs):
        super(AlbumList, self).__init__(*args, **kwArgs)

        self.app = app
        self.searcher = None

        self._command_map = AlbumListCommands()

    def search(self, pattern, reverse=False):
        self.searcher = None

        searcher = ReverseAlbumSearcher if reverse else ForwardAlbumSearcher

        try:
            self.searcher = searcher(
                pattern, self.body, self.focus_position)
            self.set_focus(self.searcher.current_match())
            return len(self.searcher.matches)
        except ValueError as err:
            logger.info('No matches found')
            logger.debug('Exception: {}'.format(err))
            return 0

    def next_search_item(self, backward=False):
        if self.searcher is None:
            logger.debug('No search found')
            return

        index = self.searcher.next_search_item(
            self.focus_position, backward=backward)

        self.set_focus(index)

    def sort_tracks(self, tracks):
        track_and_num = []
        mpd = mstat.initialize_mpd(self.app.conf)

        for i, track in enumerate(tracks):
            mpd_track = mpd.listallinfo(track.filename)
            if not mpd_track:
                continue
            trackno = str(mpd_track[0].get('track', i))
            trackno = re.sub(r'(\d+)/\d+', r'\1', trackno)

            track_and_num.append((int(trackno), track))

        return sorted(track_and_num)

    def expand_album(self, album_widget):
        current = self.focus_position
        album = album_widget.original_widget.album

        sorted_tracks = self.sort_tracks(album.tracks)
        for track_no, track in reversed(sorted_tracks):
            track_widget = SelectableTrack(album_widget, track, track_no)

            urwid.connect_signal(track_widget, 'enqueue',
                                 self.app.enqueue_track)
            urwid.connect_signal(track_widget, 'play', self.app.play_track)

            item = urwid.AttrMap(track_widget, 'track', 'focus track')
            self.body.insert(current + 1, item)

        album_widget.original_widget.expanded = True
        #self.body.insert(current + 1, self.focus)

    def collapse_album(self, album_widget):
        current = self.focus_position
        album_index = self.body.index(album_widget, 0, current + 1)

        logger.debug('Album index: {}'.format(album_index))

        album = album_widget.original_widget.album
        for i in range(len(album.tracks)):
            track_widget = self.body[album_index + 1]
            if isinstance(track_widget.original_widget, SelectableTrack):
                self.body.pop(album_index + 1)
            else:
                logger.error('Item #{} is not a track'.format(i))

        album_widget.original_widget.expanded = False

    def toggle_expand(self):
        widget = self.focus

        if isinstance(widget.original_widget, SelectableTrack):
            widget = widget.original_widget.parent

        if widget.original_widget.expanded:
            self.collapse_album(widget)
        else:
            self.expand_album(widget)

        album = widget.original_widget.album

        logger.info('Expand: {} ({} tracks)'.format(
            album_text(album),
            len(album.tracks)))

    def keypress(self, size, key):
        cmd = self._command_map[key]
        if cmd in (SEARCH_NEXT, SEARCH_PREV):
            backward = (cmd == SEARCH_PREV)
            self.next_search_item(backward=backward)
        elif cmd in (GO_TO_TOP, GO_TO_BOTTOM):
            self.set_focus(0 if cmd == GO_TO_TOP else len(self.body) - 1)
        elif cmd == 'expand':
            self.toggle_expand()
        else:
            return super(AlbumList, self).keypress(size, key)

        # Necessary to get list focus to redraw
        super(AlbumList, self).keypress(size, None)

        return True


class SelectableAlbum(urwid.WidgetWrap):
    __metaclass__ = urwid.signals.MetaSignals
    signals = ['enqueue', 'play']

    def __init__(self, suggestion):
        self.album = album = suggestion.album
        self.expanded = False
        text = album_text(album)
        super(SelectableAlbum, self).__init__(urwid.SelectableIcon(text))

        self._command_map = AlbumListCommands()

    def keypress(self, size, key):
        if self._command_map[key] == 'enqueue':
            urwid.emit_signal(self, 'enqueue', self.album)
        elif self._command_map[key] == 'play':
            urwid.emit_signal(self, 'play', self.album)
        else:
            return key


class SelectableTrack(urwid.WidgetWrap):
    __metaclass__ = urwid.signals.MetaSignals
    signals = ['enqueue', 'play']

    def __init__(self, parent, track, track_no):
        self.parent = parent
        self.track = track
        self.track_no = track_no
        text = ' + {} - {}'.format(track_no, track.name)
        super(SelectableTrack, self).__init__(urwid.SelectableIcon(text))

        self._command_map = AlbumListCommands()

    def keypress(self, size, key):
        if self._command_map[key] == 'enqueue':
            urwid.emit_signal(self, 'enqueue', self.track)
        elif self._command_map[key] == 'play':
            urwid.emit_signal(self, 'play', self.track)
        else:
            return key


class ListSearcher(urwid.Edit):
    __metaclass__ = urwid.signals.MetaSignals
    signals = ['search_done']

    def keypress(self, size, key):
        if key == 'enter':
            urwid.emit_signal(self, 'search_done', self.get_edit_text())
        elif key == 'esc':
            urwid.emit_signal(self, 'search_done', None)
        else:
            super(ListSearcher, self).keypress(size, key)

        return True


class CommanderEdit(urwid.Edit):
    __metaclass__ = urwid.signals.MetaSignals
    signals = ['command_done']

    def keypress(self, size, key):
        if key == 'enter':
            urwid.emit_signal(self, 'command_done', self.get_edit_text())
        elif key == 'esc':
            urwid.emit_signal(self, 'command_done', None)
        else:
            super(CommanderEdit, self).keypress(size, key)

        return True


def main():
    conf = mstat.configuration(path='suggestive.conf')

    logging.basicConfig(level=logging.DEBUG, filename='log.txt', filemode='w')
    logger.info('Starting event loop')

    app = Application(conf)

    try:
        app.event_loop.run()
    except KeyboardInterrupt:
        logger.error("Exited via keyboard interrupt; next time, use 'q'")


if __name__ == '__main__':
    main()

#! /usr/bin/python3.2

import urwid
import logging
import threading
import mstat
from analytics import Analytics
from datetime import datetime
from subprocess import call
from itertools import chain, islice
import re

logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())

ENQUEUE = 'enqueue'
PLAY = 'play'

#
# Threads
#


class AppThread(threading.Thread):
    pass


class DatabaseUpdateThread(AppThread):

    def __init__(self, conf, callback, *args, **kwArgs):
        super(DatabaseUpdateThread, self).__init__(*args, **kwArgs)
        self.callback = callback
        self.conf = conf

        self.session = mstat.initialize_sqlalchemy(conf)
        self.mpd = mstat.initialize_mpd(conf)
        self.lastfm = mstat.initialize_lastfm(conf)

    def run(self):
        mstat.update_database(self.session, self.mpd, self.lastfm, self.conf)
        logger.info('Finished update')
        (self.callback)()


#
# Main Functions
#


class Application(object):

    def __init__(self, conf):
        self.conf = conf

        self.mpd = mstat.initialize_mpd(conf)
        session = mstat.initialize_sqlalchemy(conf)
        self.anl = Analytics(session)

        self.suggestions = []
        self.last_updated = datetime.now()

        # urwid stuff
        self.list_view = self.suggestion_list()

        main = urwid.Padding(self.list_view, left=2, right=2)
        self.content = urwid.Filler(main, height=('relative', 100),
                                    valign='middle', top=1, bottom=1)
        self.top = urwid.Frame(self.content)

        self.event_loop = self.main_loop()

    def start_db_update(self):
        self.update_status('Updating database')
        update_thread = DatabaseUpdateThread(self.conf, self.update_event)
        update_thread.daemon = False
        update_thread.start()

    def update_event(self):
        self.event_loop.set_alarm_in(0, self.update_suggestions)

    def update_suggestions(self, *_args):
        logger.info('Update suggestions display')
        self.last_updated = datetime.now()
        self.suggestions = self.get_suggestions()

        self.list_view = self.suggestion_list()
        padded = urwid.Padding(self.list_view, left=2, right=2)
        self.content.set_body(padded)

        self.update_status('Idle')
        self.update_header()

    def get_suggestions(self):
        return self.anl.loved_order()

        # self.suggestions = self.anl.suggest_albums()
        #self.list_view = self.suggestion_list()
        #self.update_header()
        #self.update_status('Idle')

    def enqueue_album(self, widget_, album):
        logger.info('Enqueue: {} - {}'.format(album.artist.name, album.name))
        mpd_tracks = list(chain.from_iterable(
            self.mpd.listallinfo(track.filename) for track in album.tracks))

        for i, track in enumerate(mpd_tracks):
            trackno = str(track.get('track', i))
            trackno = re.sub(r'(\d+)/\d+', r'\1', trackno)
            track['track'] = int(trackno)

        sorted_tracks = sorted(mpd_tracks, key=lambda track: track['track'])
        ids = [self.mpd.addid(track['file']) for track in sorted_tracks]
        return ids

    def play_album(self, widget_, album):
        logger.info('Play: {} - {}'.format(album.artist.name, album.name))
        self.mpd.clear()
        ids = self.enqueue_album(widget_, album)
        if ids:
            self.mpd.playid(ids[0])

    def update_header(self):
        timestamp = self.last_updated.strftime('%Y-%m-%d %H:%M:%S')
        upd = urwid.Text('Last updated: {}'.format(timestamp))
        header = urwid.Pile([upd, urwid.Divider('\u2500')])
        self.top.set_header(header)

        return header

    def update_status(self, status):
        status = urwid.Text(status)
        footer = urwid.Pile([urwid.Divider('\u2500'), status])
        self.top.set_footer(footer)

        return footer

    def dispatch(self, key):
        if key == 'q':
            raise urwid.ExitMainLoop()
        elif key == 'u':
            self.start_db_update()
        elif key == 'r':
            self.update_suggestions()
        elif key == '~':
            self.event_loop.screen.stop()
            call('ncmpcpp', shell=True)
            self.event_loop.screen.start()
        elif key == '/':
            self.start_search()

    def start_search(self):
        self.edit = ListSearcher('Search:')
        urwid.connect_signal(self.edit, 'done', self.search_done)
        footer = urwid.Pile([urwid.Divider('\u2500'), self.edit])
        self.top.set_footer(footer)
        self.top.set_focus('footer')

    def search_done(self, pattern):
        self.top.set_focus('body')
        urwid.disconnect_signal(self, self.edit, 'done', self.search_done)

        if pattern is not None:
            logger.info('SEARCH FOR: {}'.format(pattern))
            self.search(pattern)

        self.update_status('Idle')

    def search(self, pattern, reverse=False):
        current = self.list_view.focus_position
        logger.debug('Current position: {}'.format(current))
        if reverse:
            logger.debug('Reverse search')
            suggestions = reversed(self.suggestions)
            current = len(self.suggestions) - current
        else:
            suggestions = self.suggestions

        ordered = chain(
            islice(suggestions, current, None),
            islice(suggestions, 0, current)
        )

        items = ('{} - {}'.format(sug.album.artist.name, sug.album.name)
                 for sug in ordered)

        indices = [
            i for i, item in enumerate(items)
            if re.search(pattern, item, re.I) is not None
        ]

        if reverse:
            indices = [len(self.suggestions) - index for index in indices]

        self.search_matches = [
            (current + index) % len(self.suggestions)
            for index in indices
        ]

        if self.search_matches:
            index = self.search_matches[0]
            if index == current and len(self.search_matches) > 1:
                index = self.search_matches[1]

            logger.debug('Found item at index {}'.format(index))
            self.list_view.set_focus(index)

    def suggestion_list(self):
        if not self.suggestions:
            body = [urwid.Text('MPD database is empty')]
        else:
            body = []

        for suggestion in self.suggestions:
            item = SelectableAlbum(suggestion)

            urwid.connect_signal(item, 'enqueue', self.enqueue_album,
                                 item.album)
            urwid.connect_signal(item, 'play', self.play_album, item.album)

            body.append(urwid.AttrMap(item, None, focus_map='reversed'))

        box = urwid.ListBox(urwid.SimpleFocusListWalker(body))
        box._command_map = AlbumListCommands()
        return box

    def main_loop(self):
        logger.info('Starting event loop')

        self.update_suggestions()
        # self.start_db_update()

        return urwid.MainLoop(self.top, palette=[('reversed', 'standout', '')],
                              unhandled_input=self.dispatch)


class AlbumListCommands(urwid.CommandMap):
    DEFAULT_BINDINGS = {
        'cursor up': ('k', 'up'),
        'cursor down': ('j', 'down'),
        'cursor left': ('h', 'left'),
        'cursor right': ('l', 'right'),
        'cursor page up': ('ctrl b', 'page up'),
        'cursor page down': ('ctrl f', 'page down'),
        'cursor max left': ('g', 'home'),
        'cursor max right': ('G', 'end'),
        'quit': ('q',),
        'update': ('u',),
        'reload': ('r',),
        ENQUEUE: (' ',),
        PLAY: ('enter',),
    }

    @classmethod
    def _flatten(cls, bindings):
        flattened = {}
        for action, keys in bindings.items():
            flattened.update({key: action for key in keys})

        return flattened

    def __init__(self, *args, **kwArgs):
        super(AlbumListCommands, self).__init__()
        self.update(self._flatten(self.DEFAULT_BINDINGS))
        self.update(*args, **kwArgs)

    def update(self, *args, **kwArgs):
        if args and isinstance(args[0], dict):
            bindings = args[0]
        else:
            bindings = kwArgs

        for key, command in bindings.items():
            self.__setitem__(key, command)


class SelectableAlbum(urwid.WidgetWrap):
    __metaclass__ = urwid.signals.MetaSignals
    signals = ['enqueue', 'play']

    def __init__(self, suggestion):
        self.album = album = suggestion.album
        text = '{} - {} ({}/{} loved)'.format(
            album.artist.name, album.name, len(suggestion.loved),
            len(album.tracks))
        super(SelectableAlbum, self).__init__(urwid.SelectableIcon(text))

        self._command_map = AlbumListCommands()

    def keypress(self, size, key):
        if self._command_map[key] == ENQUEUE:
            self._emit('enqueue')
        elif self._command_map[key] == PLAY:
            self._emit('play')
        else:
            return key


class ListSearcher(urwid.Edit):
    __metaclass__ = urwid.signals.MetaSignals
    signals = ['done']

    def keypress(self, size, key):
        if key == 'enter':
            urwid.emit_signal(self, 'done', self.get_edit_text())
            return
        elif key == 'esc':
            urwid.emit_signal(self, 'done', None)
            return

        super(ListSearcher, self).keypress(size, key)


def main():
    conf = mstat.configuration(path='suggestive.conf')

    logging.basicConfig(level=logging.DEBUG, filename='log.txt', filemode='w')
    logger.info('Starting event loop')

    app = Application(conf)

    app.event_loop.run()


if __name__ == '__main__':
    main()
